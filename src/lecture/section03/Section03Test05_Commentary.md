# **에라토스테네스의 체 및 소수/합성수 개념 완전 정리**

## **1️⃣ 소수와 합성수의 정의**

### **소수 (Prime Number)**

* **1과 자기 자신만 약수로 가지는 1보다 큰 자연수**
* 약수의 개수 = **2개**

#### **예시**

| 수 | 약수   | 결과 |
| - | ---- | -- |
| 2 | 1, 2 | 소수 |
| 3 | 1, 3 | 소수 |
| 5 | 1, 5 | 소수 |

---

### **합성수 (Composite Number)**

* **1과 자기 자신 외에 다른 약수를 가지는 1보다 큰 자연수**
* **N = p × q** 꼴로 표현 가능
* p와 q는 모두 **1보다 큰 자연수**

#### **예시**

| 수  | 약수          | 표현    | 결과  |
| -- | ----------- | ----- | --- |
| 4  | 1, 2, 4     | 2 × 2 | 합성수 |
| 6  | 1, 2, 3, 6  | 2 × 3 | 합성수 |
| 9  | 1, 3, 9     | 3 × 3 | 합성수 |
| 15 | 1, 3, 5, 15 | 3 × 5 | 합성수 |

---

### **1은 예외**

* **1은 소수도 아니고 합성수도 아닙니다.**

---

## **2️⃣ 에라토스테네스의 체**

### **목적**

* 2부터 n까지 **모든 소수를 구하는 알고리즘**

---

### **핵심 아이디어**

* **모든 합성수는 반드시 작은 소수의 배수로 표현할 수 있다.**

즉,

> 어떤 합성수 N은 반드시 `N = p × q` 꼴로 나타낼 수 있는데,
> 이때 **p 또는 q 중 적어도 하나는 √N 이하의 소수이다.**

---

### **왜 그런가요?**

가정:
`p`와 `q`가 모두 `√N`보다 크다면?

```
N = p × q > √N × √N = N
```

→ **모순 발생!**

그래서 반드시 **p 또는 q는 √N 이하**의 수여야 합니다.

---

## **3️⃣ 알고리즘 동작 과정**

1. 2부터 n까지 모든 수를 **소수라고 가정**하고 시작한다.
2. 2부터 √n까지 반복하면서:

    * 소수인 경우 그 배수들을 지운다.
3. 남아있는 수가 소수이다.

---

## **4️⃣ 왜 `i × i`부터 배수 지우기를 시작하나요?**

### **이유**

* **이미 작은 소수들이 `i × 2`, `i × 3`, ..., `i × (i-1)` 까지 지웠기 때문**

---

### **예시**

#### i = 3일 때:

* `3 × 2 = 6`
  → 이미 i=2에서 `2×3=6`으로 지워졌음.
* `3 × 3 = 9`
  → **여기서부터 지워야 할 첫 숫자**

---

### **수식으로 설명**

모든 합성수 `N`은 두 수의 곱으로 표현됩니다:

```
N = p × q  (p ≤ q)
```

* 만약 `p < i`, `q ≥ i`라면,
  → 이미 `p`에서 `p×q` 형태로 지워졌음.
* `p = i`, `q ≥ i`일 때는
  → **이제 처음으로 지워지는 경우.**

**즉, `i × i`부터 지워야 함**

---

### **그림으로 요약**

| 숫자      | 누가 지우는가           |
| ------- | ----------------- |
| `i × 2` | 이전 소수에서 이미 지움     |
| `i × 3` | 이전 소수에서 이미 지움     |
| `i × i` | **이제 지우기 시작해야 함** |

---

## **5️⃣ 왜 `i * i <= n`까지만 반복하나요?**

* √n보다 큰 소수들은 배수를 지울 필요가 없습니다.
* **그 이후의 배수는 이미 작은 소수에서 다 지워졌기 때문**

---

## **6️⃣ 시간복잡도와 효율성**

| 항목        | 복잡도                |
| --------- | ------------------ |
| **시간복잡도** | **O(n log log n)** |
| **공간복잡도** | **O(n)**           |

---

## **7️⃣ 전통적인 방식 (`j=2*i`)과의 차이**

| 구분        | `j = 2*i` 방식 | `j = i*i` 방식           |
| --------- | ------------ | ---------------------- |
| **중복 제거** | ❌ 중복 지움 있음   | ✅ 중복 제거                |
| **속도**    | 느림           | 빠름                     |
| **용도**    | 교육용, 단순 구현   | **실전 알고리즘, 최적화된 체 구현** |

---

## **8️⃣ 비유로 이해하기**

**소수로 체를 "거름망"처럼 씌운다고 생각하세요.**

* 작은 소수일수록 더 많이 걸러냄.
* **`i×i` 이하의 배수는 이미 앞 단계에서 다 걸러짐.**

---

## **9️⃣ 참고 코드 (Java)**

```java
boolean[] isPrime = new boolean[n + 1];
Arrays.fill(isPrime, true);
isPrime[0] = false;
isPrime[1] = false;

for (int i = 2; i * i <= n; i++) {
    if (isPrime[i]) {
        for (int j = i * i; j <= n; j += i) {
            isPrime[j] = false;
        }
    }
}

int result = 0;
for (boolean isTrue : isPrime) {
    if (isTrue) result++;
}

System.out.println("소수 개수: " + result);
```

---

## **🔑 최종 요약**

| 개념               | 설명                            |
| ---------------- | ----------------------------- |
| **합성수**          | N = p × q 꼴로 표현 가능한 1보다 큰 자연수 |
| **소수**           | 1과 자기 자신만 약수로 가지는 수           |
| **에라토스테네스의 체**   | 소수의 배수만 지우는 효율적 소수 판별법        |
| **`i × i`부터 시작** | 중복 제거와 효율성 향상                 |
| **√n까지만 검사**     | 이후는 이미 다 지워짐                  |
